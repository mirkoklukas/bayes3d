# AUTOGENERATED! DO NOT EDIT! File to edit: ../../scripts/notebooks/_mkl/99 - Importance Sampling.ipynb.

# %% auto 0
__all__ = ['logsumexp', 'vmap', 'keysplit']

# %% ../../scripts/notebooks/_mkl/99 - Importance Sampling.ipynb 2
import genjax
from genjax import gen
import jax.numpy as jnp
import jax
from jax import jit, vmap

# %% ../../scripts/notebooks/_mkl/99 - Importance Sampling.ipynb 4
def keysplit(key, *ns):
    if len(ns) == 0:
        return jax.random.split(key, 1)[0]
    
    if len(ns) == 1:
        return jax.random.split(key, ns[0])
    else:

        keys = []
        for n in ns:
            if n == 1: keys.append(jax.random.split(key, 1)[0])
            else: keys.append(jax.random.split(key, n))

        return keys

# %% ../../scripts/notebooks/_mkl/99 - Importance Sampling.ipynb 5
logsumexp = jax.scipy.special.logsumexp
vmap      = jax.vmap

# %% ../../scripts/notebooks/_mkl/99 - Importance Sampling.ipynb 6
#
# Gen.jl style ordering of the args and return values
#
def _merge(x,y): return x.merge(y)


def _simulate(key, model, args):
    return model.simulate(key, args)


def _propose(key, model, args):
    k, tr = model.simulate(key, args)
    # Note: `strip` returns a stripped choice map
    return k, (tr.strip(), tr.get_score(), tr.get_retval())


def _generate(key, model, args, constr):
    k, (w, tr) = model.importance(key, constr, args)
    return k, (tr, w)


def _importance_sampling(key, 
                        model, args, obs, 
                        proposal, proposal_args,   
                        N:int):
    """
    Importance sampling with custom proposal 

    Usage:
    ```python

        N = 100
        _importance_sampling_jit = jit(partial(_importance_sampling, N=N))
        key, (trs, ws, lml) = _importance_sampling_jit(key, model, args, obs, prop, prop_args)

    ```
    """

    key, keys = keysplit(key,1,N)

    # Get some proposed choices
    # and merge them into the given observation
    keys, (prop_ch, prop_ws, _) = vmap(_propose, (0, None, None))(
        keys, proposal, proposal_args)
    
    constr, _ = vmap(_merge, (0,None))(prop_ch, obs)

    # Generate new traces given these new constraints
    keys, (trs, ws) = vmap(_generate, in_axes=(0,None,None,0))(
        keys, model, args, constr)
    
    # Adjust the importance weights accordingly
    ws    = ws - prop_ws
    total = logsumexp(ws)
    ws    = ws - total          # Log normalize
    lml   = total - jnp.log(N)  # Estimate of the (log) marginal likelihood

    return key, (trs, ws, lml)


